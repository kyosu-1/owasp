# 認証・認可を理解する

モノリスなアプリケーションからマイクロサービスまでの認証・認可の全体像(特にOauth2.0とOpenID Connect)を掴むことを目的とした資料です。

様々なトピックを扱っているため各内容の詳細は説明していませんが、詳細が記載されている参考記事やドキュメントのリンクを載せているため、必要に応じて参照してください。

# 今回扱うもの

1. 認証・認可の基本概念
2. 従来(モノリスなアプリケーション)の認証・認可とマイクロサービスの課題
3. OAuth2.0とOpenID Connect
4. その他話題(SSO, IDaaSなど)

# 1. 認証・認可の基本概念

## 認証・認可とは

* 認証(Authentication)
  * **通信の相手が誰（何）であるかを確認すること**
  * 知識、所有、生体認証といった三要素のいずれかまたは複合して利用
    * 2要素以上を必要とするものをMFA(多要素認証)という
* 認可(Authorization)
  * **とある特定の条件に対して、リソースアクセスの権限を与えること**
  * **それを持っている**ことによって**何か（リソースアクセス）**が**許可**される
  * **最小特権の原則**を適用することが望ましい

認証と認可は、アプリケーションのセキュリティにおいて非常に重要な役割を担う。
多くのアプリケーションの脆弱性は認証・認可の設計及び実装の不備に起因する。

**参考**

- [よく分かる認証・認可](https://dev.classmethod.jp/articles/authentication-and-authorization/)

## 認証とMFA

- [MFAとは(AWS)](https://aws.amazon.com/jp/what-is/mfa/)

## 認可と最小特権の原則

* 最小特権の原則は、ユーザーやリソースが自分のタスクを実行するために必要な最小限のアクセス権を持つべきであるというもの。
* 例えば、一般社員が機密性の高い財務データや管理機能にアクセスできるようにすべきではない。ユーザーの役割に基づいてアクセスを制限することで、不正なアクセスやデータ漏洩を防ぐことができる。
* 認可設計の原則として開発者は意識する必要がある

**参考**

- [最小特権の原則とは](https://www.cloudflare.com/ja-jp/learning/access-management/principle-of-least-privilege/)
- [A01_2021-Broken_Access_Control](https://owasp.org/Top10/A01_2021-Broken_Access_Control/)
  - 最小特権の原則を守らないことによる脆弱性

# 2. 従来(モノリスなアプリケーション)の認証・認可とマイクロサービスの課題

## 従来(モノリスなアプリケーション)の認証・認可

まず代表的な以下の3つの認証方法をモノリスなアプリケーションにおけるフローを通じて見ていく。(以下の認証方法自体がモノリスなアプリケーション特有のものというわけではない)

- basic認証
- セッションストア方式
- トークン方式

### Basic認証

* HTTPで定義される認証方式の一つで、もっとも単純な実装方式
* Authorizationヘッダに`[ID]:[PASSWORD]`の形でBase64エンコードしたものを入れてリクエストを送る

#### Basic認証のフロー

![](https://camo.qiitausercontent.com/5dd9f79328db0f49df2f8a8d2618d8dd296ca634/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e61702d6e6f727468656173742d312e616d617a6f6e6177732e636f6d2f302f3931323938322f31363663336236352d303461312d386263382d656165662d6133653432323234616466372e706e67)

[引用元](https://qiita.com/hitomik/items/38befaf0d740c4b07363)

#### Basic認証の特徴

* ステートレスな認証方式
  * 一度認証したとしてもその認証状態を維持しない
* ECサイトなどの一般的なwebサービスで利用されることはないが、ページの限定公開を簡易的に行うことに使われることがある
* Basic認証は平文でのパスワード送信を伴うので、HTTP通信では安全ではない(最低限HTTPS化することが望ましい)
  * [RFC7617](https://datatracker.ietf.org/doc/html/rfc7617)より

### セッションストア方式

ステートレスなHTTP通信をステートフルにして、認証を維持させる方式

[RFC6265: HTTP State Management Mechanism](https://www.rfc-editor.org/rfc/rfc6265)

#### セッションストア方式のフロー

![](https://storage.googleapis.com/zenn-user-upload/cbe792e9c14c-20221015.png)

[引用元](https://zenn.dev/tanaka_takeru/articles/3fe82159a045f7)

#### セッションストア方式のフロー

1. ログインによるユーザーの認証を経て、サーバー側でSessionIDを発行しCookieにセットする
   1. セッションIDは一意であり、短期間で有効期限が切れる
2. SessionIDとそれに紐づくユーザー情報をサーバー側で持つ(RDBやKVSに保存)
3. 再度リクエストを投げた際にはリクエスト(Cookie)に含まれるセッションIDを確認

### トークン方式

トークン（デジタルな証明書）を用いてユーザーの身元を確認し、セキュアなアクセスを提供する認証方法。トークンとしてはJWTが代表的

**参考**

* [RFC7519: JSON Web Token (JWT)](https://www.rfc-editor.org/rfc/rfc7519)
* [jwt-auth](https://developer.mamezou-tech.com/blogs/2022/12/08/jwt-auth/)

#### トークン方式のフロー

![](https://storage.googleapis.com/zenn-user-upload/dcc08ae4b06c-20221015.png)

[引用元](https://zenn.dev/tanaka_takeru/articles/3fe82159a045f7)

1. サーバーが認証情報を含むトークン（例：JWT）を生成し、クライアントに送信する
2. クライアントはこのトークンを保存し、以降のリクエストでトークンをサーバーに送信することで、ユーザーが認証済みであることを証明。
3. トークンは、有効期限や署名などの情報を含んでおり、サーバーはトークンを検証して認証状態を確認

#### トークン方式とセッション方式の比較

(モノリスなアプリケーションの例に限らない比較)

* 最大の違いはサーバー側で状態を持つかどうか
  * セッション方式はステートフルで、トークン方式はステートレス
  * この違いからトークン方式はセッション方式と比較して分散アプリケーションに強い(上記はモノリスなアプリケーションの例)
    * トークン方式は状態を持たないため、各サーバーで独立して検証を行える
      * セッション方式はセッションストアからデータを確認する必要あり
      * (スケールアウトするようなストアを利用すれば緩和)
  * 一方でトークンはサーバー側で情報を持っていないため、トークンは無効化することは難しい
    * セッションはログアウトによりサーバー側でストアから無効化できるが、トークンはあくまでクライアント側で棄却するのみ

**参考**
* [安全なウェブサイトの作り方 - 1.4 セッション管理の不備](https://www.ipa.go.jp/security/vuln/websecurity/session-management.html)
* [セッションベース認証とトークンベース認証の違い](https://zenn.dev/tanaka_takeru/articles/3fe82159a045f7) 

### 従来(モノリスなアプリケーション)の認証・認可のまとめ

* モノリスアプリケーションにおいてはリソースを提供するサーバーでセッションやトークンを発行し、それを管理することで認証を実現する
  * モノリスなアプリケーションではセッションベースが多い。
* **認可は基本的に認証に基づく**
  * ログインしたユーザーのロールとかで管理
  * ユーザーが直接ブラウザ上から操作することのみを想定されたモノリスアプリケーションにおいては大体これで十分
  * 一方でマイクロサービスだと...

**参考**

* [セッションベース認証とトークンベース認証の違い](https://zenn.dev/tanaka_takeru/articles/3fe82159a045f7) 

## モノリスからマイクロサービスへ

* 近年のwebアプリケーションにおいてはほとんどがAPIを通じた複数のサービス間通信を含むもの
  * ここでのマイクロサービスはgoogleのような巨大なものだけでなく、slackアプリやYoutube API等と一部連携するようなサービスも含む
* 認証・認可に関してもマイクロサービスに適したものを考える必要がある

![](https://ncdc.co.jp/wp-content/uploads/2020/02/%E3%83%9E%E3%82%A4%E3%82%AF%E3%83%AD%E3%82%B5%E3%83%BC%E3%83%92%E3%82%99%E3%82%B91.jpeg.webp)
[引用元](https://ncdc.co.jp/columns/6503/)

## マイクロサービスにおける認証・認可の課題

複数の独立したサービスで構成されるマイクロサービスにおいて、例えばモノリスなアプリケーションにおける単純なセッションベースの認証は(DBを共有していなければ)データの共有の問題から同じ実装では利用できない

このようにマイクロサービスにおける認証・認可の設計にはモノリスなアプリケーションと比較して様々な課題がある。

* セキュリティの一貫性: 異なるマイクロサービス間で認証・認可の仕組みが統一されていない場合、セキュリティの一貫性が損なわれ、脆弱性が生じる可能性がある。
* セッション管理の複雑さ: マイクロサービス間でセッション情報を共有する必要がある場合、セッション管理が複雑になり、データの同期や共有の課題が生じる。
* サービス間の認可ポリシーの維持: マイクロサービスが増えることで、それぞれのサービス間の認可ポリシーを維持・管理することが難しくなる。認可ロジックの変更が必要になった際に、一貫性のある更新が困難になることがある。

これらの課題を踏まえ、複数のサービス間のセキュアで一貫した認証・認可の方式を定義した**Oauth2.0**と**OpenID Connect**が存在する。

また、1度のユーザー認証によって複数のシステム（業務アプリケーションやクラウドサービスなど）の利用が可能になる仕組みである**SSO**の採用事例も多い。

# 3. OAuth2.0とOpenID Connect

## OAuth2.0とOpenID Connectとは

* OAuth2.0
  * **認可フレームワーク**
  * クライアントがリソースオーナー（ユーザー）のリソースに安全にアクセスできる方法を提供する
  * アクセストークンを使用してAPIにアクセス
  * 複数の認可フローを提供
* OpenID Connect
  * **認証プロトコル**
  * **OAuth2.0の拡張**
  * IDトークンを通じてユーザー認証を提供する
  * 認証サーバー（OpenIDプロバイダー）により、ユーザー情報を一元管理

**参考(詳細な定義)**
* OAuth2.0
  * [RFC6749](https://datatracker.ietf.org/doc/html/rfc6749)
* OpenID Connect
  * [RFC7591](https://www.rfc-editor.org/rfc/rfc7591.html)
  * [openid-connect-core-1_0](https://openid.net/specs/openid-connect-core-1_0.html)

## OAuth2.0(OpenID Connect)のアクター

- Client（Relying Party, RP）
  - 認可を受け、保護されたリソースに対してアクションを行う
- Authorization Server（OpenID Provider, OP, Identity Provider, IdP）
  - リソース所有者の同意を得て、保護されたリソースに対してアクセストークン（IDトークン）を発行する
- Resource Server
  - OAuthによって保護されたリソースを所有するサーバー
- Resource Owner
  - OAuthによって保護されたリソースを持つユーザー

## Oauth2.0のデモ(google API)

以下がgoによるOauth2.0のデモアプリ

https://github.com/kyosu-1/go-oauth

## OAuth2.0のフロー

OAuth2.0のフローは、クライアント（通常はアプリケーション）がリソースオーナー（ユーザー）からリソースサーバー（ユーザーデータが格納されているサーバー）へのアクセス許可を得るための一連の手順である。
OAuth2.0には、以下の4つの主要なフロー（グラントタイプ）が存在する。

1. 認可コードフロー（Authorization Code Flow）
2. インプリシットフロー（Implicit Flow）
3. リソースオーナーパスワードクレデンシャルフロー（Resource Owner Password Credentials Flow）
4. クライアントクレデンシャルフロー（Client Credentials Flow）
5. リフレッシュトークンフロー（Refresh Token Flow）

[以下の各フローの引用元：OAuth 2.0 全フローの図解と動画](https://qiita.com/TakahikoKawasaki/items/200951e5b5929f840a1f)

### 認可コードフロー（Authorization Code Flow）

![](https://camo.qiitausercontent.com/cbceb0f0e391aeeb9220c484838d0c13e730c75d/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f3130363034342f64393131396632312d373336642d643565642d393634642d3330363861663066636465392e706e67)

* 最も一般的でセキュアなフロー
* クライアントがユーザーの認証情報を直接扱わず、認可サーバーを介してアクセストークンを取得
* フロントエンドとバックエンドで処理が分割されるため、セキュリティが向上
* ウェブアプリケーションやモバイルアプリケーションに適している

### インプリシットフロー（Implicit Flow）

![](https://camo.qiitausercontent.com/f405619d2c12dc344be3dfd06303bcd60996de23/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f3130363034342f37343365326432372d353132642d663262382d656537322d3161386333313562376637362e706e67)

* 認可コードフローを簡略化したフロー
* 認可サーバーが認可コードの代わりに直接アクセストークンを返す
* クライアントシークレットやトークン交換の手順がないため、セキュリティが弱い
* シングルページアプリケーション（SPA）向けであったが、現在は認可コードフローにPKCEを適用した方が推奨されている
  * [OAuth2.0認可コードフロー+PKCEをシーケンス図で理解する](https://zenn.dev/zaki_yama/articles/oauth2-authorization-code-grant-and-pkce)
    * 認可コードが盗まれた場合でも、攻撃者はコードベリファイアを持っていないためアクセストークンを取得できない

### リソースオーナーパスワードクレデンシャルフロー（Resource Owner Password Credentials Flow）

![](https://camo.qiitausercontent.com/e5ec64c0720ad524686c56c827f130326f838697/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f3130363034342f66383664326537632d366562382d613464342d303561382d6236666533363765613235652e706e67)


* ユーザーのユーザ名とパスワードをクライアントが直接取り扱う
* クライアントが信頼性が高い場合（自社開発のアプリケーションなど）にのみ適用されるべき
* セキュリティが弱いため、他のフローが適用できる場合はそちらを選択すべき

### クライアントクレデンシャルフロー（Client Credentials Flow）

![](https://camo.qiitausercontent.com/db046530a661d77bf16e6202697cb655d3cd3d9d/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f3130363034342f36303332343938302d313365612d323133382d326638652d3635653938306366636362332e706e67)

* ユーザーの認証情報を利用せず、クライアント自身の認証情報（クライアントIDとクライアントシークレット）でアクセストークンを取得
* ユーザーではなく、クライアントがリソースサーバー上のリソースを管理・操作する場合に適用されるサーバー間の認可に適している

### リフレッシュトークンフロー（Refresh Token Flow）

![](https://camo.qiitausercontent.com/c67db031f2e1eea042c5afe5b07ec7dde2cb6503/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f3130363034342f39386664383733302d353030372d386666612d643734332d3831653935313538323533322e706e67)

* アクセストークンの有効期限が切れた場合に、新しいアクセストークンを取得するためのフロー
* リフレッシュトークンは、認可サーバーからアクセストークンと一緒に発行される
* クライアントはリフレッシュトークンを使用して、ユーザーの再認証なしで新しいアクセストークンを取得できる
* リフレッシュトークンは長期的に保持され、繰り返し使用されるため、セキュリティ上のリスクがある
* リフレッシュトークンの使用は、信頼性の高いクライアント（ウェブアプリケーションやモバイルアプリケーションなど）に限定されるべき
* 認可コードフローやリソースオーナーパスワードクレデンシャルフローと組み合わせて使用されることが一般的

## OAuth2.0は何を解決するのか

OAuth2.0は以下のような点で課題解決を行う。

* 認可情報の共有
  * OAuth2.0では、アクセストークンを用いてサービス間で認可情報を共有できる。ユーザーが確認(承認)を行った後、認可サーバーからアクセストークンを取得し、それを用いて各サービスにアクセス可能となる。これにより、ユーザーは複数のサービスを利用する際に都度認証・認可を行う必要がなくなる。
* セキュリティの一貫性
  * OAuth2.0では、認可の処理を中央の認可サーバーに集約する。これにより、各サービスが独自の認可処理を実装することなく、セキュリティポリシーを一貫して適用することが可能となる。
* スケーラビリティの向上
  * OAuth2.0を導入することで、ユーザー認証やアクセス権限の管理が一元化され、システム全体のスケーラビリティが向上します。また、認可サーバーは独立してスケールすることが可能であり、大規模なシステムにも対応できる。
* サードパーティアプリケーションへの安全なデータアクセス
  * OAuth2.0では、ユーザーがサードパーティアプリケーションに自分のデータへのアクセスを許可できる。ユーザーはパスワードを共有することなく、サードパーティアプリケーションに一定期間・特定の操作のみ許可することができる。

## OAuth2.0でないもの

- HTTPプロトコルを使わずに定義されることはない
  - Bearerトークンを使う際にメッセージの署名は行われないため、HTTPSではないネットワークで使われることは想定されていない
- 認証のプロトコルとはない
  - OAuthを使って認証を行う仕組みを構築することは可能ではあるが、Oauth2.0のトランザクションそのものからはユーザーが誰なのか、ユーザーがそこにいるのかは知ることはできないようになっている。
- 認可プロセスの仕組みを定義していない
  - 権限の以上が行われたことを伝えるための手段は提供するが、その認可の中身に関しては定義していない
  - スコープやトークンを使ってどのようなアクションを行えるかを定義するのはサービスのAPIが決めること
- 暗号に関する方法については定義していない
  - 限定されず様々な暗号方式が適用できる
- 単一のプロトコルではない
  - 前述のように複数の定義とフローに分かれており、それぞれが独自のユースケースをもつ

## OAuth2.0は認証に使えない？

[OAuth認証とは何か?なぜダメなのか - 2020冬](https://ritou.hatenablog.com/entry/2020/12/01/000000)

## OpenID Connect

[OpenID Connect 全フロー解説](https://qiita.com/TakahikoKawasaki/items/4ee9b55db9f7ef352b47)

### OpenID Connectのフロー

## 脆弱性と対策

[図解：OAuth 2.0に潜む「5つの脆弱性」と解決法](https://atmarkit.itmedia.co.jp/ait/articles/1710/24/news011.html)

## まとめ

* Oauth2.0
  * 認可のフレームワーク(プロトコルと言われる場合もあるが単一のプロトコルではないことに注意)
* OpenID Connect
  * Oauth2.0を拡張した認証プロトコル
  * ID連携を行うことでSSOも実現可能

**参考**

* [OAuth徹底入門 セキュアな認可システムを適用するための原則と実践](https://www.shoeisha.co.jp/book/detail/9784798159294)
  * 非常に詳細にまとめられおり、実際にコードをハンズオンで実装するところまで扱っている書籍
* [一番分かりやすい OAuth の説明](https://qiita.com/TakahikoKawasaki/items/e37caf50776e00e733be)
* [一番分かりやすい OpenID Connect の説明](https://qiita.com/TakahikoKawasaki/items/498ca08bbfcc341691fe)
* [Authentication_Cheat_Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)
* [マイクロサービスの認証・認可とJWT](https://speakerdeck.com/oracle4engineer/authentication-and-authorization-in-microservices-and-jwt)
* [Microservices における認証と認可の設計パターン](https://please-sleep.cou929.nu/microservices-auth-design.html)

# 4. その他話題

## SSO

## IDaaS

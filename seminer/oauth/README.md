# 認証・認可を理解する

モノリスなアプリケーションからマイクロサービスまでの認証・認可の全体像を掴むことを目的とした資料です。

様々なトピックを扱っているため各内容の詳細は説明していませんが、詳細が記載されている参考記事やドキュメントのリンクを載せているため、必要に応じて参照してください。

# 今回扱うもの

1. 認証・認可の基本概念
2. 従来(モノリスなアプリケーション)の認証方法とマイクロサービスの課題
3. OAuth2.0とOpenID Connectに関して
4. OAuth2.0のデモ
5. 脆弱性と対策
6. IDaaSとシングルサインオン(SSO)

# 認証・認可の基本概念

## 認証・認可とは

* 認証(Authentication)
  * **通信の相手が誰（何）であるかを確認すること**
  * 知識、所有、生体認証といった三要素のいずれかまたは複合して利用
    * 2要素以上を必要とするものをMFA(多要素認証)という
* 認可(Authorization)
  * **とある特定の条件に対して、リソースアクセスの権限を与えること**
  * **それを持っている**ことによって**何か（リソースアクセス）**が**許可**される
  * **最小特権の原則**を適用することが望ましい

**参考**

- [よく分かる認証・認可](https://dev.classmethod.jp/articles/authentication-and-authorization/)

## 認証とMFA

- [MFAとは(AWS)](https://aws.amazon.com/jp/what-is/mfa/)

## 認可と最小特権の原則

* 最小特権の原則は、ユーザーやリソースが自分のタスクを実行するために必要な最小限のアクセス権を持つべきであるというもの。
* 例えば、一般社員が機密性の高い財務データや管理機能にアクセスできるようにすべきではない。ユーザーの役割に基づいてアクセスを制限することで、不正なアクセスやデータ漏洩を防ぐことができる。
* 認可設計の原則として開発者は意識する必要がある

**参考**

- [最小特権の原則とは](https://www.cloudflare.com/ja-jp/learning/access-management/principle-of-least-privilege/)
- [A01_2021-Broken_Access_Control](https://owasp.org/Top10/A01_2021-Broken_Access_Control/)
  - 最小特権の原則を守らないことによる脆弱性

# 従来(モノリスなアプリケーション)の認証方法とマイクロサービスの課題

## 従来(モノリスなアプリケーション)の認証方法

### Basic認証

* HTTPで定義される認証方式の一つで、もっとも単純な実装方式
* Authorizationヘッダに`[ID]:[PASSWORD]`の形でBase64エンコードしたものを入れてリクエストを送る

#### Basic認証のフロー

![](https://camo.qiitausercontent.com/5dd9f79328db0f49df2f8a8d2618d8dd296ca634/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e61702d6e6f727468656173742d312e616d617a6f6e6177732e636f6d2f302f3931323938322f31363663336236352d303461312d386263382d656165662d6133653432323234616466372e706e67)

[引用元](https://qiita.com/hitomik/items/38befaf0d740c4b07363)

#### Basic認証の特徴

* ステートレスな認証方式
  * 一度認証したとしてもその認証状態を維持しない
* ECサイトなどの一般的なwebサービスで利用されることはないが、ページの限定公開を簡易的に行うことに使われることがある
* Basic認証は平文でのパスワード送信を伴うので、HTTP通信では安全ではない(最低限HTTPS化することが望ましい)
  * [RFC7617](https://datatracker.ietf.org/doc/html/rfc7617)より

### セッションストア方式

ステートレスなHTTP通信をステートフルにして、認証を維持させる方式

[RFC6265: HTTP State Management Mechanism](https://www.rfc-editor.org/rfc/rfc6265)

#### セッションストア方式のフロー

![](https://storage.googleapis.com/zenn-user-upload/cbe792e9c14c-20221015.png)

[引用元](https://zenn.dev/tanaka_takeru/articles/3fe82159a045f7)

#### セッションストア方式のフロー

1. ログインによるユーザーの認証を経て、サーバー側でSessionIDを発行しCookieにセットする
  * セッションIDは一意であり、短期間で有効期限が切れる
2. SessionIDとそれに紐づくユーザー情報をサーバー側で持つ(RDBやKVSに保存)
3. 再度リクエストを投げた際にはリクエスト(Cookie)に含まれるセッションIDを確認

#### セッションストア方式の特徴

* ステートフルで、クライアント(ユーザー)の状態を管理できる
* 脆弱性の観点
  * セッションIDが盗まれた場合、不正なアクセスが行われる可能性がある
    * 推測困難なものを生成する必要がある

**参考**
* [安全なウェブサイトの作り方 - 1.4 セッション管理の不備](https://www.ipa.go.jp/security/vuln/websecurity/session-management.html)

### トークン方式

トークン（デジタルな証明書）を用いてユーザーの身元を確認し、セキュアなアクセスを提供する認証方法。トークンとしてはJWTが代表的

**参考**

* [RFC7519: JSON Web Token (JWT)](https://www.rfc-editor.org/rfc/rfc7519)
* [jwt-auth](https://developer.mamezou-tech.com/blogs/2022/12/08/jwt-auth/)

#### トークン方式のフロー

![](https://storage.googleapis.com/zenn-user-upload/dcc08ae4b06c-20221015.png)

[引用元](https://zenn.dev/tanaka_takeru/articles/3fe82159a045f7)

1. サーバーが認証情報を含むトークン（例：JWT）を生成し、クライアントに送信する
2. クライアントはこのトークンを保存し、以降のリクエストでトークンをサーバーに送信することで、ユーザーが認証済みであることを証明。
3. トークンは、有効期限や署名などの情報を含んでおり、サーバーはトークンを検証して認証状態を確認

### トークン方式とセッション方式の認証の比較

* 最大の違いはサーバー側で状態を持つかどうか
  * セッション方式はステートフルで、トークン方式はステートレス
  * この違いからトークン方式はセッション方式と比較して分散アプリケーションに強い
    * トークン方式は状態を持たないため、各サーバーで独立して検証を行える
      * セッション方式はセッションストアからデータを確認する必要あり
      * (スケールアウトするようなストアを利用すれば緩和)
  * 一方でトークンはサーバー側で情報を持っていないため、トークンは無効化することは難しい
    * セッションはログアウトによりサーバー側でストアから無効化できるが、トークンはあくまでクライアント側で棄却するのみ

**参考**

* [セッションベース認証とトークンベース認証の違い](https://zenn.dev/tanaka_takeru/articles/3fe82159a045f7) 
